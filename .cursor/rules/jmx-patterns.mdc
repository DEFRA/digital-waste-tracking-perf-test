---
description: JMX File Patterns and Implementation
globs:
alwaysApply: true
---

# JMX File Patterns and Implementation

## Standard JMX File Structure

### Test Plan Level Components
Every JMX file should include these components at the Test Plan level:

1. **User Defined Variables**: Set `testType` parameter for test-specific customization
2. **Payload Generation**: JSR223PreProcessor for dynamic data generation
3. **Shared Authentication**: JSR223PreProcessor for token management
4. **Think Time**: UniformRandomTimer for realistic user behavior

### Thread Group Configuration Patterns

#### Baseline Tests (Single Request)
- **User Count**: 1 user
- **Ramp-up**: 1 second
- **Loops**: 1 iteration
- **Scheduler**: Disabled (fixed loop execution)
- **Purpose**: Functional validation and baseline metrics

#### Load/Stress Tests (Duration-Based)
- **User Count**: 30-50 users
- **Ramp-up**: 180-300 seconds
- **Duration**: 1800 seconds (30 minutes)
- **Scheduler**: Enabled (`ThreadGroup.scheduler=true`)
- **Loops**: -1 (infinite during duration)
- **Purpose**: Sustained load testing

#### Spike Tests (Multi-Phase)
- **Phase 1**: 5 users, 30s ramp-up, 300s duration (baseline)
- **Phase 2**: 50 users, 5s ramp-up, 60s duration (spike)
- **Phase 3**: 5 users, 10s ramp-up, 300s duration (recovery)
- **Total Duration**: ~11 minutes
- **Purpose**: Test system behavior under sudden load spikes

## HTTP Request Configuration

### Standard HTTP Sampler Pattern
```xml
<HTTPSamplerProxy testname="Create Waste Movement">
  <stringProp name="HTTPSampler.domain">waste-movement-external-api.api.${__P(environment)}.cdp-int.defra.cloud</stringProp>
  <stringProp name="HTTPSampler.protocol">https</stringProp>
  <stringProp name="HTTPSampler.path">/movements/receive</stringProp>
  <stringProp name="HTTPSampler.method">POST</stringProp>
  <boolProp name="HTTPSampler.postBodyRaw">false</boolProp>
  <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
    <collectionProp name="Arguments.arguments">
      <elementProp name="" elementType="HTTPArgument">
        <boolProp name="HTTPArgument.always_encode">false</boolProp>
        <boolProp name="HTTPArgument.use_equals">false</boolProp>
        <stringProp name="Argument.value">${postPayload}</stringProp>
      </elementProp>
    </collectionProp>
  </elementProp>
</HTTPSamplerProxy>
```

### Key Configuration Rules
- **Use HTTP Arguments**: Set `postBodyRaw=false` and use HTTP Arguments for complex JSON
- **Variable Substitution**: Use `${postPayload}` for POST/create operations and `${putPayload}` for PUT/update operations
- **Empty Argument Name**: Use empty argument name to make value become entire request body
- **No Encoding**: Set `always_encode=false` and `use_equals=false` for JSON content
- **Headers**: Use HeaderManager for Content-Type and Authorization headers
- **Authorization**: Use `${__P(global_access_token)}` for shared authentication token

## Standard Components

### Required Components for All JMX Files
1. **Test Plan Level**:
   - User Defined Variables with `testType` parameter
   - JSR223PreProcessor for payload generation
   - JSR223PreProcessor for shared authentication
   - UniformRandomTimer for think time (500ms base + 1000ms range)

2. **Thread Group Level**:
   - HTTP Samplers with HTTP Arguments configuration
   - HeaderManager for Content-Type and Authorization
   - ResponseAssertion for success validation
   - JSONPostProcessor for data extraction (when needed)

3. **HTTP Sampler Configuration**:
   - Use `${__P(environment)}` for domain configuration
   - Set `postBodyRaw=false` for JSON payloads
   - Use HTTP Arguments with empty name for request body
   - Set `always_encode=false` and `use_equals=false`

## Naming Conventions

### Test Plan Names
- **Single Operation**: `"[Operation] Waste Movement - [Test Type] Test"`
- **Multi-Step Workflow**: `"[Step 1] and [Step 2] Waste Movement - [Test Type] Test"`
- **Examples**: 
  - `"Create Waste Movement - Baseline Test"`
  - `"Create and Update Waste Movement - Baseline Test"`
  - `"Create Waste Movement - Spike Test"`

### ThreadGroup Names
- **Single Operation**: `"[Operation] Waste Movement"`
- **Multi-Step Workflow**: `"[Step 1] and [Step 2] Waste Movement"`
- **Spike Test Phases**: `"Spike Phase [X] - [Description]"`
- **Examples**:
  - `"Create Waste Movement"`
  - `"Create and Update Waste Movement"`
  - `"Spike Phase 1 - Low Load"`
  - `"Spike Phase 2 - High Load"`
  - `"Spike Phase 3 - Recovery"`

### HTTP Sampler Names
- **Clear Operation**: `"[Operation] Waste Movement"`
- **Examples**: `"Create Waste Movement"`, `"Update Waste Movement"`

### JSR223PreProcessor Names
- **Authentication**: `"Get Access Token"`
- **Payload Generation**: `"Generate [Operation] Waste Movement Payload"`
- **Examples**: 
  - `"Generate Create Waste Movement Payload"`
  - `"Generate Update Waste Movement Payload"`

### Response Assertion Names
- **Specific Validation**: `"Verify [Operation] Response Success"`
- **Examples**: 
  - `"Verify Create Response Success"`
  - `"Verify Update Response Success"`

### PostProcessor Names
- **Data Extraction**: `"Extract [Data Type]"`
- **Examples**: `"Extract Global Movement ID"`

## Implementation Guidelines

### Properties Usage
- Use `${__P(propertyName)}` for all configurable values
- Use `${__P(environment)}` for environment-specific URLs
- Use `${__P(global_access_token)}` for shared authentication token

### External Scripts
- Reference Groovy files with `filename` property
- Use `scripts/get_accessToken.groovy` for authentication
- Use `scripts/create_waste_movement_payload.groovy` for create operations
- Use `scripts/update_waste_movement_payload.groovy` for update operations

### Variable Usage
- Use `${postPayload}` for POST/create operations
- Use `${putPayload}` for PUT/update operations
- Use `${testType}` for test-specific customization
- Use `${globalMovementId}` for data extraction and updates

## Best Practices

### Do's
- Always use shared authentication pattern
- Use HTTP Arguments for JSON payloads with variable substitution
- Include think time simulation for realistic behavior
- Use descriptive names that explain functionality
- Follow consistent naming patterns across all files
- Use external Groovy scripts for dynamic data generation

### Don'ts
- Don't use postBodyRaw for complex JSON payloads
- Don't hardcode authentication in individual JMX files
- Don't embed JSON directly in JMX files
- Don't use static values in names (user counts, etc.)
- Don't skip think time simulation
- Don't hardcode environment-specific values

## Goal
Create portable, maintainable test plans that focus purely on the test flow and business logic, with all configuration externalized to command-line scripts and property files.